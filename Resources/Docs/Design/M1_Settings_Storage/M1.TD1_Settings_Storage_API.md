# (M1.TD1) Technical Design: Settings Storage API

## Changelog

- 20-02-2024 - 13:19 - @vacmg - Add module working mode (Persistent/Volatile) methods & attributes. Improve readability & improve description of initialize(), finalize() & restoreSettings()
- 07-02-2024 - 17:00 - @vacmg - Changed the responsability of restoring default settings from the caller to the initialize function.
- 24-01-2024 - 18:07 - @vacmg - Make restore settings functions definitions more concise.
- 23-01-2024 - 14:50 - @vacmg - Change Macro CONFIG_SETTINGS_DELAYED_WRITE_TIME_MS name.
- 23-01-2024 - 14:18 - @aom20021 - Add restore settings functionality to the API.
- 23-01-2024 - 11:50 - @vacmg - Add changelog section to follow the TD template.
- Not recorded date - @vacmg - Base document.

## Description

This technical design shows the public API used to interact with the settings storage module.

## Module Name: SettingsStorage::Settings

- Action
    - [x] Create
    - [ ] Modify
    - [ ] Delete

## Interface

- Type
    - [x] Class
    - [ ] Test
    - [ ] Config

## Function (Optional)

List and sublist of modules configuration. A key value pair of \<String, Sublist\> or \<String, Data\>.

## Dependencies (Optional)
- SettingsParser (M1.TD2)
- [Timer](https://espressif-docs.readthedocs-hosted.com/projects/esp-idf/en/latest/api-reference/peripherals/timer.html)
- [fmt library](https://github.com/fmtlib/fmt): string formatter library
- [esp_log.h](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/log.html): ESP logging libary

## Test Cases (Optional)
None

## Attachments


### Additional info:

This is the technical design of the unique class in the Settings module that is public. All the interactions from outside this module will be used from this class.

### API:

#### Macro **CONFIG_SETTINGS_DISABLE_DELAYED_WRITE**:
- When this macro is true, it will disable the delayed write operations mechanism, by writing instantly to persistent storage after calling putSetting().
- When this macro is undefined or false, this behaviour will be disabled.
- Adding this item will allow to use â€œCONFIG_SETTINGS_DISABLE_DELAYED_WRITE" as a preprocessor macro to allow or exclude code from being compiled:

    ```
    #if defined(CONFIG_SETTINGS_DISABLE_DELAYED_WRITE)
    ...
    #endif
    ```

#### Macro **CONFIG_SETTINGS_DELAYED_WRITE_TIME_MS**:
- Adding this macro will allow to use "CONFIG_SETTINGS_DELAYED_SAVE_TIME_MS" as a preprocessor macro to be used as symbol in the code with the value of the time to wait when using the delayed save mechanism:

    ```
    timer_set_counter_value(...,CONFIG_SETTINGS_RETARDED_SAVE_TIME_MS);
    ```

#### **public Class Settings** (static)

##### Class that handles all the interaction with Settings module

##### Structs:

- **typedef enum  {NO_ERROR = 0, KEY_NOT_FOUND_ERROR, TYPE_MISMATCH_ERROR, KEY_EXISTS_ERROR, CORRUPTED_SETTINGS_FILE_ERROR, MODULE_ALREADY_REGISTERED_ERROR, INVALID_INPUT_ERROR, SETTINGS_NOT_INITIALIZED_ERROR} SettingError_t;**
  // Enum that stores the possible errors returned by the API Settings.

- **typedef enum {VOID = 0, SETTINGS_MAP, FLOAT, INT, STRING} SettingValueType_t;**
  // Enum with the types of data that can be saved.

- **typedef union {float FLOAT; int INT; std::string\* STRING; std::unordered_map<std::string, struct SettingValue_t>\* SETTING_MAP;} SettingValueData_t;**
  // Union with the types of data that can be saved.

- **typedef struct SettingValue_t {
  SettingValueType_t settingValueType;
  SettingValueData_t settingValueData;
  } SettingValue_t;**
  // The value of each map element SettingsMap_t

- **typedef std::unordered_map<std::string, SettingValue_t> SettingsMap_t;**
  // The data type that stores a map of key string and struct value with the settings.

    - **SettingValueType_t settingValueType** (VOID/SETTINGS_MAP/FLOAT/INT/STRING)
      // A flag that tells what type of value it stores (in brackets are the possible values)

    - **SettingValueData_t settingValueData**
      // The value itself that is stored.

- **typedef void (\*RestoreModuleDefaultSettingsCallback_t)(bool generateSettingStructure);**
  // The data type that the settings restore functionality uses. All modules that use settings must register a function of this type where they restore the default settings for the module using putSetting(...) and, if generateSettingStructure is true, they also have to use addSetting(...) prior to putSetting to generate each setting entry.

- **typedef std::unordered_map<std::string, RestoreModuleDefaultSettingsCallback_t> RestoreModuleDefaultSettingsCallbackMap_t;**
  // The data type that stores a map with the function pointers needed to restore each module default settings.

##### Attributes:

- **private SettingsMap_t\* settingsMap**
  // The pointer to the map that stores the settings
  Mutual exclusion must be guaranteed when accessing between reads and writes, and ensure that only one write can be made at a time.

- **private bool initialized**
  // Returns true if init has been called without irrecoverable errors, false otherwise. Any function of this class called when this attribute is false must return false or SETTINGS_NOT_INITIALIZED_ERROR

- **public const SettingValue_t VOID_VALUE** = {.settingValueType = VOID, .settingValueData = 0}
  // There is a special struct that has settingValueType = VOID and settingValueData indeterminate. It is used to indicate that this key is empty.

- **private RestoreModuleDefaultSettingsCallbackMap_t restoreModuleDefaultSettingsCallbackMap**
  // This is the map of functions that restore the default settings of each module.

- **private bool persistentStorageEnabled**
  // This attribute saves the current mode of operation of the module: Normal/Persistent Mode or Failsafe/Volatile Mode.
    - The mode of operation can be downgraded from normal to volatile mode at anytime due to internal or external errors regarding the storage partition filesystem.

##### Methods:

- **public SettingError_t registerModuleRestoreCallback(const std::string& moduleName, RestoreModuleDefaultSettingsCallback_t callback)**
  // This function saves the provided restore function (callback) in a map that matches moduleNames with callbacks (restoreModuleDefaultSettingsCallbackMap).
  The module name is selected from one of **LogUtils.h** module name (COMPONENT_NAME_[MODULE_NAME]) strings.
  - This function works as expected even if initialized is false.
  - If **moduleName** is **nullptr** or **""**, it returns **INVALID_INPUT_ERROR** and the callback is not saved.
  - If **moduleName** is already registered, it returns **MODULE_ALREADY_REGISTERED_ERROR** and the callback is not saved.
  - If **moduleName** is not registered, the callback is saved in **restoreModuleDefaultSettingsCallbackMap** and it returns **NO_ERROR**.

- **public SettingError_t initialize()**
  // Initializes **settingsMap**, gets & validate data from flash and store it in settingsMap using SettingsParser Class.
    - If **persistentStorageEnabled** is **false**, instead of loading the map from the storage, it will **create a new map** with default settings.
    - Returns **NO_ERROR** if the init process is ok, or **CORRUPTED_SETTINGS_FILE_ERROR** if the parser encounters an error.
    - Even though the parser returns nullptr, **Settings Storage must work**, so depending on the error reported, the filesystem must be remounted, or a new empty map must be created & saved, or if everything else fails, it should backup to a volatile only mode (where it only saves the configuration in memory, rather than in storage).
    - If **CORRUPTED_SETTINGS_FILE_ERROR** is returned, initialize must restore default settings.
    - **initialized** attribute value **always change to true** after calling this function.
    - Before calling **initialize()**, **registerModuleRestoreCallback()** must be called to get each module's restore function.

- **public void finalize()**
  // This function saves the settingMap to persistent storage, deletes settingsMap object, set initialized to false & persistentStorageEnabled to default.
    - After calling this function, any function of this class called must return **false** or **SETTINGS_NOT_INITIALIZED_ERROR** unless **initialize()** is called again.

- **public bool isPersistentStorageEnabled()**
  // This function returns true if the module mode is set to Normal/Persistent mode, meaning that settings are saved in flash, or false if the module mode is set to volatile mode (config is not persistent between reboots)
  - This function works as expected even if initialized is false.
  - 
- **public void disablePersistentStorage()**
  // This function changes the module mode to volatile mode.
    - This function works as expected even if initialized is false.

- **public SettingValue_t getSetting(const std::string& key)**
  // Gets a **settingsMap value** (Object in RAM) given a path as key (if it is a submenu, it is separated by '/' character).
    - Returns the SettingValue_t object associated with the key; or the special struct VOID_VALUE in case the key is not found or if key is nullptr or "".
    - **Several reads can be performed concurrently, but none during write**.

- **public SettingError_t putSetting(...)**
    - **SettingError_t putSetting(const std::string& key, int value)**
    - **SettingError_t putSetting(const std::string& key, float value)**
    - **SettingError_t putSetting(const std::string& key, const char\* value)**
      // It updates the value associated to the key with the value in settingsMap and updates the copy in flash at the moment or in a delayed way (if it is a submenu, it is separated by the character '/').
    - **Special care must be taken when working with pointers to objects, to avoid memory leaks, the function must destroy the object to be replaced with delete, and create the substitute with new.**
    - If the **key** is of a **different type than the existing one, and is different from VOID**, **TYPE_MISMATCH** is returned;
    - If the **key** is **nullptr or ""**, returns **INVALID_INPUT_ERROR**.
    - If the **key doesn't exist** in the store, it returns **KEY_NOT_FOUND**.
    - If it terminates correctly, **NO_ERROR** is returned.
    - **It must be guaranteed that only one value can be written at a time, and cannot be written while reading.**
    - The delayed written mechanism works as follows:
        1. When saving a setting with **putSetting()**, a timer is started with a time of **CONFIG_SETTINGS_RETARDED_SAVE_TIME_MS** milliseconds.
        2. When saving another setting with **putSetting()**, the timer is reset to the **CONFIG_SETTINGS_RETARDED_SAVE_TIME_MS** milliseconds value.
        3. When the timer reaches its end, **SettingsParser::writeToFile()** is called to save the settings.

- **public SettingError_t addSetting(const std::string& key)**
  // Creates a new setting with the key value key, and the special struct VOID_VALUE
  (if it is a submenu, it is separated by the '/' character and creates all the necessary submenus if they do not already exist).
    - If the **key** is **nullptr or ""**, returns **INVALID_INPUT_ERROR**.
    - If the **key already exists**, returns **KEY_EXISTS**.
    - If successful, **NO_ERROR** is returned.
    - **It must be guaranteed that only one value can be written at a time, and cannot be written while reading.**

- **public SettingError_t restoreSettings(const std::string& moduleName = "")**
  // This function restores the default settings of the provided module, or all settings if moduleName is "" using the callback map "restoreModuleDefaultSettingsCallbackMap".
  The module name is selected from one of LogUtils.h module name (COMPONENT_NAME_[MODULE_NAME]) strings.
  - If **moduleName** = **nullptr** it returns **INVALID_INPUT_ERROR** and performs no operation.
  - If **moduleName** is **not previously registered** using registerModuleRestoreCallback(), it returns **KEY_NOT_FOUND_ERROR** and performs no operation.
  - If **moduleName** is **registered, or is ""**, it will call the corresponding restore settings callbacks and return **NO_ERROR**.
  - After settings restore, it will call **writeSettingsToPersistentStorage()**.

- **public const bool writeSettingsToPersistentStorage()**
  // This function writes the current settingsMap to flash using the SettingsParser class.
  - If **delayed write is enabled**, it will also **cancel the timer** if it is active.
  - If **persistentStorageEnabled** is **false**, it will do nothing and return **false**.

- **public const char\* getSettingsTree(const std::string& key)**
  // This function returns a formatted string (allocated in heap) using fmt library with the subtree that hangs from key (in a recursive way):
  KEY_STR
  |-SUBKEY1_STR --- VALUE1
  |-SUBKEY2_STR --- VALUE2
  |-SUBMAP_STR
  | |-SUBKEY3_STR --- VALUE3
  |-SUBKEY4_STR --- VALUE4
    - If key is not a SETTINGS_MAP entry, it returns only the entry pointed by key (KEY_STR --- VALUE).
    - If the key points to a SETTINGS_MAP entry, it returns the whole subtree:
    - If the key is '/', nullptr or '': it will return the complete settings tree.
    - If the key does not exist: it will return nullptr




##### Example:

    - Example data:
	    Settings are stored in SettingsMap_t as follows:
        - [...] indicate a map.
        - (...) indicates the spacing between each SettingValue_t.
        - (...) indicates a SettingValue_t

        SettingMap_t: [ ('Setting1', 23.56), ('Energy', [ ('MaxVoltage',12), ('SensorName', 'MySensorName') ]) ]

    - Example of API usage:

        int main()
        {
            if(Settings::init() == Settings::NO_ERROR)
            {
                Settings::addSetting("setting1");
                Settings::putSetting("setting1", "value1");
                
                const char* buff = Settings::getSettingsTree("/");
                fmt::print("{}",buff);
                free(buff);

                Settings::SettingValue_t res = Settings::getSetting("setting1");
                if(res.settingValueType!=Settings::STRING)
                    return -1;
                const char* string = res.settingValueData.STRING->c_str();
                
                Settings::writeSettingsToPersistentStorage();
            }
            return 0;
        }

